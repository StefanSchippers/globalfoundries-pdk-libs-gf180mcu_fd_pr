################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################


if FEOL
    #================================================
    #----------------------COMP----------------------
    #================================================

    logger.info("Starting comp derivations")
    # Comp derivations
    comp_3p3v = comp.not_interacting(v5_xtor).not_interacting(dualgate)
    comp_56v  = comp.overlapping(dualgate)
    
    ncomp_3p3v = nplus.and(comp_3p3v)
    ncomp_56v  = nplus.and(comp_56v)
    
    pcomp_3p3v = pplus.and(comp_3p3v)
    pcomp_56v  = pplus.and(comp_56v)

    comp_butted = comp.and(ncomp.interacting(pcomp).outside(pcomp))

    ntap = ncomp.not_interacting(tgate)
    ntap_dn = ntap.inside(dnwell)

    ncomp_dn = ncomp.inside(dnwell)
    ncomp_out_dn = ncomp.outside(dnwell)

    ncomp_out_nw_dn = ncomp.outside(nwell).outside(dnwell)
    pcomp_out_nw_dn = pcomp.outside(nwell).outside(dnwell)
    pcomp_out_dn = pcomp.outside(nwell)

    # Rule DF.1a_3.3V: Min. COMP Width. is 0.22µm
    logger.info("Executing rule DF.1a_3.3V")
    df1a_l1  = comp_3p3v.width(0.22.um, euclidian).polygons(0.001)
    df1a_l1.output("DF.1a_3.3V", "DF.1a_3.3V : Min. COMP Width. : 0.22µm")
    df1a_l1.forget

    # Rule DF.1a_5V: Min. COMP Width. is 0.3µm
    logger.info("Executing rule DF.1a_5V")
    df1a_l1  = comp_56v.not_inside(mvsd.or(mvpsd)).width(0.3.um, euclidian).polygons(0.001)
    df1a_l1.output("DF.1a_5V", "DF.1a_5V : Min. COMP Width. : 0.3µm")
    df1a_l1.forget

    # rule DF.1b_3.3V is not a DRC check

    # rule DF.1b_5V is not a DRC check

    # Rule DF.1c_3.3V: Min. COMP Width for MOSCAP. is 1µm
    logger.info("Executing rule DF.1c_3.3V")
    df1c_l1  = comp_3p3v.and(mos_cap_mk).width(1.um, euclidian).polygons(0.001)
    df1c_l1.output("DF.1c_3.3V", "DF.1c_3.3V : Min. COMP Width for MOSCAP. : 1µm")
    df1c_l1.forget

    # Rule DF.1c_5V: Min. COMP Width for MOSCAP. is 1µm
    logger.info("Executing rule DF.1c_5V")
    df1c_l1  = comp_56v.and(mos_cap_mk).width(1.um, euclidian).polygons(0.001)
    df1c_l1.output("DF.1c_5V", "DF.1c_5V : Min. COMP Width for MOSCAP. : 1µm")
    df1c_l1.forget

    # Rule DF.2a_3.3V: Min Channel Width. is nil,0.22µm
    logger.info("Executing rule DF.2a_3.3V")
    df_2a_3p3v = comp_3p3v.not(poly2).edges.and(tgate.edges)
    df2a_l1 = df_2a_3p3v.with_length(nil,0.22.um).extended(0, 0, 0.001, 0.001)
    df2a_l1.output("DF.2a_3.3V", "DF.2a_3.3V : Min Channel Width. : nil,0.22µm")
    df2a_l1.forget
    df_2a_3p3v.forget

    # Rule DF.2a_5V: Min Channel Width. is nil,0.3µm
    logger.info("Executing rule DF.2a_5V")
    df_2a_56v = comp_56v.not(poly2).edges.and(tgate.edges)
    df2a_l1 = df_2a_56v.with_length(nil,0.3.um).extended(0, 0, 0.001, 0.001)
    df2a_l1.output("DF.2a_5V", "DF.2a_5V : Min Channel Width. : nil,0.3µm")
    df2a_l1.forget
    df_2a_56v.forget

    # Rule DF.2b_3.3V: Max. COMP width for all cases except those used for capacitors, marked by ‘MOS_CAP_MK’ layer. is 100um
    logger.info("Executing rule DF.2b_3.3V")
    df_2b = comp.not_inside(mos_cap_mk).width(100.um + 1.dbu).polygons(0.001)
    df2b_l1 = comp_3p3v.not_inside(mos_cap_mk).not(df_2b)
    df2b_l1.output("DF.2b_3.3V", "DF.2b_3.3V : Max. COMP width for all cases except those used for capacitors, marked by 'MOS_CAP_MK' layer: 100um")
    df2b_l1.forget

    # Rule DF.2b_5V: Max. COMP width for all cases except those used for capacitors, marked by ‘MOS_CAP_MK’ layer. is 100um
    logger.info("Executing rule DF.2b_5V")
    df2b_l1 = comp_56v.not_inside(mos_cap_mk).not(df_2b)
    df2b_l1.output("DF.2b_5V", "DF.2b_5V : Max. COMP width for all cases except those used for capacitors, marked by 'MOS_CAP_MK' layer: 100um")
    df2b_l1.forget
    df_2b.forget

    # Rule DF.3a_3.3V:  Min. COMP Space : 0.28µm. [P-substrate tap (PCOMP outside NWELL and DNWELL) can be butted for different voltage devices as the potential is same]
    logger.info("Executing rule DF.3a_3.3V")
    df3a_l1  = comp_3p3v.not(otp_mk).space(0.28.um, euclidian).polygons(0.001)
    df3a_l1.output("DF.3a_3.3V", "DF.3a_3.3V : Min. COMP Space is : 0.28µm. [P-substrate tap (PCOMP outside NWELL and DNWELL) can be butted for different voltage devices as the potential is same]")
    df3a_l1.forget

    # Rule DF.3a_5V:  Min. COMP Space is : 0.36µm. [P-substrate tap (PCOMP outside NWELL and DNWELL) can be butted for different voltage devices as the potential is same]
    logger.info("Executing rule DF.3a_5V")
    df3a_l1  = comp_56v.not(otp_mk).space(0.36.um, euclidian).polygons(0.001)
    df3a_l1.output("DF.3a_5V", "DF.3a_5V :  Min. COMP Space is : 0.36µm. [P-substrate tap (PCOMP outside NWELL and DNWELL) can be butted for different voltage devices as the potential is same]")
    df3a_l1.forget

    # Rule DF.3b_3.3V: Min./Max. NCOMP Space to PCOMP in the same well for butted COMP. (MOSCAP butting is not allowed). is 0 um
    logger.info("Executing rule DF.3b_3.3V")
    df_3b_same_well = ncomp.inside(nwell).not_outside(pcomp.inside(nwell)).or(ncomp.inside(lvpwell).not_outside(pcomp.inside(lvpwell)))
    df_3b_moscap = comp_butted.inside(mos_cap_mk)
    df3b_l1 = comp_3p3v.and(df_3b_same_well.or(df_3b_moscap))
    df3b_l1.output("DF.3b_3.3V", "DF.3b_3.3V : Min./Max. NCOMP Space to PCOMP in the same well for butted COMP (MOSCAP butting is not allowed): 0 um")
    df3b_l1.forget

    # Rule DF.3b_5V: Min./Max. NCOMP Space to PCOMP in the same well for butted COMP(MOSCAP butting is not allowed). is 0 um
    logger.info("Executing rule DF.3b_5V")
    df3b_l1 = comp_56v.and(df_3b_same_well.or(df_3b_moscap))
    df3b_l1.output("DF.3b_5V", "DF.3b_5V : Min./Max. NCOMP Space to PCOMP in the same well for butted COMP(MOSCAP butting is not allowed): 0 um")
    df3b_l1.forget
    df_3b_same_well.forget
    df_3b_moscap.forget

    # Rule DF.3c_3.3V: Min. COMP Space in BJT area (area marked by DRC_BJT layer). is 0.32µm
    logger.info("Executing rule DF.3c_3.3V")
    df3c_l1  = comp_3p3v.inside(drc_bjt).space(0.32.um, euclidian).polygons(0.001)
    df3c_l1.output("DF.3c_3.3V", "DF.3c_3.3V : Min. COMP Space in BJT area (area marked by DRC_BJT layer). : 0.32µm")
    df3c_l1.forget

    # Rule DF.3c_5V: Min. COMP Space in BJT area (area marked by DRC_BJT layer) hasn’t been assessed.
    logger.info("Executing rule DF.3c_5V")
    df3c_l1 = comp_56v.inside(drc_bjt.interacting(comp_56v,2))
    df3c_l1.output("DF.3c_5V", "DF.3c_5V : Min. COMP Space in BJT area (area marked by DRC_BJT layer) hasn't been assessed.")
    df3c_l1.forget

    # Rule DF.4a_3.3V: Min. (LVPWELL Space to NCOMP well tap) inside DNWELL. is 0.12µm
    logger.info("Executing rule DF.4a_3.3V")
    df4a_l1  = ntap_dn.not_interacting(v5_xtor).not_interacting(dualgate).separation(lvpwell_dn, 0.12.um, euclidian).polygons(0.001)
    df4a_l1.output("DF.4a_3.3V", "DF.4a_3.3V : Min. (LVPWELL Space to NCOMP well tap) inside DNWELL. : 0.12µm")
    df4a_l1.forget

    # Rule DF.4a_5V: Min. (LVPWELL Space to NCOMP well tap) inside DNWELL. is 0.16µm
    logger.info("Executing rule DF.4a_5V")
    df4a_l1  = ntap_dn.overlapping(dualgate).separation(lvpwell_dn, 0.16.um, euclidian).polygons(0.001)
    df4a_l1.output("DF.4a_5V", "DF.4a_5V : Min. (LVPWELL Space to NCOMP well tap) inside DNWELL. : 0.16µm")
    df4a_l1.forget
    ntap_dn.forget

    # Rule DF.4b_3.3V: Min. DNWELL overlap of NCOMP well tap. is 0.62µm
    logger.info("Executing rule DF.4b_3.3V")
    df4b_l1 = ntap.enclosed(dnwell, 0.62.um, euclidian).polygons(0.001)
    df4b_l2 = ntap.not_outside(dnwell).not(dnwell)
    df4b_l  = df4b_l1.or(df4b_l2).not_interacting(v5_xtor).not_interacting(dualgate)
    df4b_l.output("DF.4b_3.3V", "DF.4b_3.3V : Min. DNWELL overlap of NCOMP well tap. : 0.62µm")
    df4b_l1.forget
    df4b_l2.forget
    df4b_l.forget

    # Rule DF.4b_5V: Min. DNWELL overlap of NCOMP well tap. is 0.66µm
    logger.info("Executing rule DF.4b_5V")
    df4b_l1 = ntap.enclosed(dnwell, 0.66.um, euclidian).polygons(0.001)
    df4b_l2 = ntap.not_outside(dnwell).not(dnwell)
    df4b_l  = df4b_l1.or(df4b_l2).overlapping(dualgate)
    df4b_l.output("DF.4b_5V", "DF.4b_5V : Min. DNWELL overlap of NCOMP well tap. : 0.66µm")
    df4b_l1.forget
    df4b_l2.forget
    df4b_l.forget

    nwell_n_dn_out_sram = nwell_n_dn.outside(sramcore)
    # Rule DF.4c_3.3V: Min. (Nwell overlap of PCOMP) outside DNWELL. is 0.43µm
    logger.info("Executing rule DF.4c_3.3V")
    df4c_l1 = pcomp.outside(dnwell).enclosed(nwell_n_dn_out_sram, 0.43.um, euclidian).polygons(0.001)
    df4c_l2 = pcomp.outside(dnwell).not_outside(nwell_n_dn_out_sram).not(nwell_n_dn_out_sram)
    df4c_l  = df4c_l1.or(df4c_l2).not_interacting(v5_xtor).not_interacting(dualgate)
    df4c_l.output("DF.4c_3.3V", "DF.4c_3.3V : Min. (Nwell overlap of PCOMP) outside DNWELL. : 0.43µm")
    df4c_l1.forget
    df4c_l2.forget
    df4c_l.forget
    
    # Rule DF.4c_5V: Min. (Nwell overlap of PCOMP) outside DNWELL. is 0.6µm
    logger.info("Executing rule DF.4c_5V")
    df4c_l1 = pcomp.outside(dnwell).enclosed(nwell_n_dn_out_sram, 0.6.um, euclidian).polygons(0.001)
    df4c_l2 = pcomp.outside(dnwell).not_outside(nwell_n_dn_out_sram).not(nwell_n_dn_out_sram)
    df4c_l  = df4c_l1.or(df4c_l2).overlapping(dualgate)
    df4c_l.output("DF.4c_5V", "DF.4c_5V : Min. (Nwell overlap of PCOMP) outside DNWELL. : 0.6µm")
    df4c_l1.forget
    df4c_l2.forget
    df4c_l.forget
    nwell_n_dn_out_sram.forget

    # Rule DF.4d_3.3V: Min. (Nwell overlap of NCOMP) outside DNWELL. is 0.12µm
    logger.info("Executing rule DF.4d_3.3V")
    df_4d_nwell = nwell_n_dn.not_inside(ymtp_mk.or(neo_ee_mk))
    df4d_l1 = ncomp_out_dn.enclosed(df_4d_nwell, 0.12.um, euclidian).polygons(0.001)
    df4d_l2 = ncomp_out_dn.not_outside(df_4d_nwell).not(df_4d_nwell)
    df4d_l  = df4d_l1.or(df4d_l2).not_interacting(v5_xtor).not_interacting(dualgate)
    df4d_l.output("DF.4d_3.3V", "DF.4d_3.3V : Min. (Nwell overlap of NCOMP) outside DNWELL. : 0.12µm")
    df4d_l1.forget
    df4d_l2.forget
    df4d_l.forget

    # Rule DF.4d_5V: Min. (Nwell overlap of NCOMP) outside DNWELL. is 0.16µm
    logger.info("Executing rule DF.4d_5V")
    df4d_l1 = ncomp_out_dn.enclosed(df_4d_nwell, 0.16.um, euclidian).polygons(0.001)
    df4d_l2 = ncomp_out_dn.not_outside(df_4d_nwell).not(df_4d_nwell)
    df4d_l  = df4d_l1.or(df4d_l2).overlapping(dualgate)
    df4d_l.output("DF.4d_5V", "DF.4d_5V : Min. (Nwell overlap of NCOMP) outside DNWELL. : 0.16µm")
    df4d_l1.forget
    df4d_l2.forget
    df4d_l.forget

    # Rule DF.4e_3.3V: Min. DNWELL overlap of PCOMP. is 0.93µm
    logger.info("Executing rule DF.4e_3.3V")
    df4e_l1 = pcomp.enclosed(dnwell, 0.93.um, euclidian).polygons(0.001)
    df4e_l2 = pcomp.not_outside(dnwell).not(dnwell)
    df4e_l  = df4e_l1.or(df4e_l2).not_interacting(v5_xtor).not_interacting(dualgate)
    df4e_l.output("DF.4e_3.3V", "DF.4e_3.3V : Min. DNWELL overlap of PCOMP. : 0.93µm")
    df4e_l1.forget
    df4e_l2.forget
    df4e_l.forget

    # Rule DF.4e_5V: Min. DNWELL overlap of PCOMP. is 1.1µm
    logger.info("Executing rule DF.4e_5V")
    df4e_l1 = pcomp.enclosed(dnwell, 1.1.um, euclidian).polygons(0.001)
    df4e_l2 = pcomp.not_outside(dnwell).not(dnwell)
    df4e_l  = df4e_l1.or(df4e_l2).overlapping(dualgate)
    df4e_l.output("DF.4e_5V", "DF.4e_5V : Min. DNWELL overlap of PCOMP. : 1.1µm")
    df4e_l1.forget
    df4e_l2.forget
    df4e_l.forget

    # Rule DF.5_3.3V: Min. (LVPWELL overlap of PCOMP well tap) inside DNWELL. is 0.12µm
    logger.info("Executing rule DF.5_3.3V")
    df5_l1 = pcomp_out_dn.enclosed(lvpwell_dn, 0.12.um, euclidian).polygons(0.001)
    df5_l2 = pcomp_out_dn.not_outside(lvpwell_dn).not(lvpwell_dn)
    df5_l  = df5_l1.or(df5_l2).not_interacting(v5_xtor).not_interacting(dualgate)
    df5_l.output("DF.5_3.3V", "DF.5_3.3V : Min. (LVPWELL overlap of PCOMP well tap) inside DNWELL. : 0.12µm")
    df5_l1.forget
    df5_l2.forget
    df5_l.forget

    # Rule DF.5_5V: Min. (LVPWELL overlap of PCOMP well tap) inside DNWELL. is 0.16µm
    logger.info("Executing rule DF.5_5V")
    df5_l1 = pcomp_out_dn.enclosed(lvpwell_dn, 0.16.um, euclidian).polygons(0.001)
    df5_l2 = pcomp_out_dn.not_outside(lvpwell_dn).not(lvpwell_dn)
    df5_l  = df5_l1.or(df5_l2).overlapping(dualgate)
    df5_l.output("DF.5_5V", "DF.5_5V : Min. (LVPWELL overlap of PCOMP well tap) inside DNWELL. : 0.16µm")
    df5_l1.forget
    df5_l2.forget
    df5_l.forget

    df6_exclude_mk = otp_mk.or(ymtp_mk).or(sramcore).or(mvpsd).or(mvsd)
    # Rule DF.6_3.3V: Min. COMP extend beyond gate (it also means source/drain overhang). is 0.24µm
    logger.info("Executing rule DF.6_3.3V")
    df6_l1 = poly2.not_inside(df6_exclude_mk).enclosed(comp_3p3v.not_inside(df6_exclude_mk), 0.24.um, euclidian).polygons(0.001)
    df6_l1.output("DF.6_3.3V", "DF.6_3.3V : Min. COMP extend beyond gate (it also means source/drain overhang). : 0.24µm")
    df6_l1.forget

    # Rule DF.6_5V: Min. COMP extend beyond gate (it also means source/drain overhang). is 0.4µm
    logger.info("Executing rule DF.6_5V")
    df6_l1 = poly2.not_inside(df6_exclude_mk).enclosed(comp_56v.not_inside(df6_exclude_mk), 0.4.um, euclidian).polygons(0.001)
    df6_l1.output("DF.6_5V", "DF.6_5V : Min. COMP extend beyond gate (it also means source/drain overhang). : 0.4µm")
    df6_l1.forget

    # Rule DF.7_3.3V: Min. (LVPWELL Spacer to PCOMP) inside DNWELL. is 0.43µm
    logger.info("Executing rule DF.7_3.3V")
    df7_l1  = pcomp_3p3v.inside(dnwell).separation(lvpwell_dn, 0.43.um, euclidian).polygons(0.001)
    df7_l1.output("DF.7_3.3V", "DF.7_3.3V : Min. (LVPWELL Spacer to PCOMP) inside DNWELL. : 0.43µm")
    df7_l1.forget

    # Rule DF.7_5V: Min. (LVPWELL Spacer to PCOMP) inside DNWELL. is 0.6µm
    logger.info("Executing rule DF.7_5V")
    df7_l1  = pcomp_56v.inside(dnwell).outside(sramcore).separation(lvpwell_dn, 0.6.um, euclidian).polygons(0.001)
    df7_l1.output("DF.7_5V", "DF.7_5V : Min. (LVPWELL Spacer to PCOMP) inside DNWELL. : 0.6µm")
    df7_l1.forget

    # Rule DF.8_3.3V: Min. (LVPWELL overlap of NCOMP) Inside DNWELL. is 0.43µm
    logger.info("Executing rule DF.8_3.3V")
    df8_l1 = ncomp_dn.enclosed(lvpwell_dn, 0.43.um, euclidian).polygons(0.001)
    df8_l2 = ncomp_dn.not_outside(lvpwell_dn).not(lvpwell_dn)
    df8_l  = df8_l1.or(df8_l2).not_interacting(v5_xtor).not_interacting(dualgate)
    df8_l.output("DF.8_3.3V", "DF.8_3.3V : Min. (LVPWELL overlap of NCOMP) Inside DNWELL. : 0.43µm")
    df8_l1.forget
    df8_l2.forget
    df8_l.forget

    # Rule DF.8_5V: Min. (LVPWELL overlap of NCOMP) Inside DNWELL. is 0.6µm
    logger.info("Executing rule DF.8_5V")
    df8_l1 = ncomp_dn.outside(sramcore).enclosed(lvpwell_dn, 0.6.um, euclidian).polygons(0.001)
    df8_l2 = ncomp_dn.not_outside(lvpwell_dn.outside(sramcore)).not(lvpwell_dn.outside(sramcore))
    df8_l  = df8_l1.or(df8_l2).overlapping(dualgate)
    df8_l.output("DF.8_5V", "DF.8_5V : Min. (LVPWELL overlap of NCOMP) Inside DNWELL. : 0.6µm")
    df8_l1.forget
    df8_l2.forget
    df8_l.forget

    # Rule DF.9_3.3V: Min. COMP area (um2). is 0.2025µm²
    logger.info("Executing rule DF.9_3.3V")
    df9_l1  = comp_3p3v.not(otp_mk).with_area(nil, 0.2025.um)
    df9_l1.output("DF.9_3.3V", "DF.9_3.3V : Min. COMP area (um2). : 0.2025µm²")
    df9_l1.forget

    # Rule DF.9_5V: Min. COMP area (um2). is 0.2025µm²
    logger.info("Executing rule DF.9_5V")
    df9_l1  = comp_56v.not(otp_mk).with_area(nil, 0.2025.um)
    df9_l1.output("DF.9_5V", "DF.9_5V : Min. COMP area (um2). : 0.2025µm²")
    df9_l1.forget

    # Rule DF.10_3.3V: Min. field area (um2). is 0.26µm²
    logger.info("Executing rule DF.10_3.3V")
    df10_l1  = comp_3p3v.holes.not(comp_3p3v).with_area(nil, 0.26.um)
    df10_l1.output("DF.10_3.3V", "DF.10_3.3V : Min. field area (um2). : 0.26µm²")
    df10_l1.forget

    # Rule DF.10_5V: Min. field area (um2). is 0.26µm²
    logger.info("Executing rule DF.10_5V")
    df10_l1  = comp_56v.holes.not(comp_56v).with_area(nil, 0.26.um)
    df10_l1.output("DF.10_5V", "DF.10_5V : Min. field area (um2). : 0.26µm²")
    df10_l1.forget

    # Rule DF.11_3.3V: Min. Length of butting COMP edge. is 0.3µm
    logger.info("Executing rule DF.11_3.3V")
    df11_l1  = comp_3p3v.and(comp_butted).edges.inside_part(comp).with_length(nil,0.3.um).extended(0, 0, 0.001, 0.001)
    df11_l1.output("DF.11_3.3V", "DF.11_3.3V : Min. Length of butting COMP edge. : 0.3µm")
    df11_l1.forget

    # Rule DF.11_5V: Min. Length of butting COMP edge. is 0.3µm
    logger.info("Executing rule DF.11_5V")
    df11_l1  = comp_56v.and(comp_butted).edges.inside_part(comp).with_length(nil,0.3.um).extended(0, 0, 0.001, 0.001)
    df11_l1.output("DF.11_5V", "DF.11_5V : Min. Length of butting COMP edge. : 0.3µm")
    df11_l1.forget
    comp_butted.forget

    # Rule DF.12_3.3V: COMP not covered by Nplus or Pplus is forbidden (except those COMP under marking).
    logger.info("Executing rule DF.12_3.3V")
    df12_l1 = comp_3p3v.not_interacting(schottky_diode).not_inside(nplus.or(pplus))
    df12_l1.output("DF.12_3.3V", "DF.12_3.3V : COMP not covered by Nplus or Pplus is forbidden (except those COMP under marking).")
    df12_l1.forget

    # Rule DF.12_5V: COMP not covered by Nplus or Pplus is forbidden (except those COMP under marking).
    logger.info("Executing rule DF.12_5V")
    df12_l1 = comp_56v.not_interacting(schottky_diode).not_inside(nplus.or(pplus))
    df12_l1.output("DF.12_5V", "DF.12_5V : COMP not covered by Nplus or Pplus is forbidden (except those COMP under marking).")
    df12_l1.forget

    # Rule DF.13_3.3V: Max distance of Nwell tap (NCOMP inside Nwell) from (PCOMP inside Nwell) is 20um.
    logger.info("Executing rule DF.13_3.3V")
    df13_ncomp = ncomp.inside(nwell.covering(ncomp).covering(pcomp))
    df13_pcomp = pcomp.inside(nwell.covering(ncomp).covering(pcomp))    
    df13_l1 = df13_ncomp.not_interacting(v5_xtor).not_interacting(dualgate).not_interacting(df13_pcomp.sized(20.um))
    df13_l1.output("DF.13_3.3V", "DF.13_3.3V : Max distance of Nwell tap (NCOMP inside Nwell) from (PCOMP inside Nwell): 20um")
    df13_l1.forget

    # Rule DF.13_5V: Max distance of Nwell tap (NCOMP inside Nwell) from (PCOMP inside Nwell) is 20um.
    logger.info("Executing rule DF.13_5V")
    df13_l1 = df13_ncomp.overlapping(dualgate).not_interacting(df13_pcomp.sized(15.um))
    df13_l1.output("DF.13_5V", "DF.13_5V : Max distance of Nwell tap (NCOMP inside Nwell) from (PCOMP inside Nwell): 20um")
    df13_l1.forget
    df13_ncomp.forget
    df13_pcomp.forget

    # Rule DF.14_3.3V: Max distance of substrate tap (PCOMP outside Nwell) from (NCOMP outside Nwell) is 20um.
    logger.info("Executing rule DF.14_3.3V")
    df14_l1 = pcomp_3p3v.outside(nwell).not_interacting(ncomp.outside(nwell).sized(20.um))
    df14_l1.output("DF.14_3.3V", "DF.14_3.3V : Max distance of substrate tap (PCOMP outside Nwell) from (NCOMP outside Nwell): 20um")
    df14_l1.forget

    # Rule DF.14_5V: Max distance of substrate tap (PCOMP outside Nwell) from (NCOMP outside Nwell) is 20um.
    logger.info("Executing rule DF.14_5V")
    df14_l1 = pcomp_56v.outside(nwell).not_interacting(ncomp.outside(nwell).sized(15.um))
    df14_l1.output("DF.14_5V", "DF.14_5V : Max distance of substrate tap (PCOMP outside Nwell) from (NCOMP outside Nwell): 20um")
    df14_l1.forget

    # rule DF.15a_3.3V is not a DRC check

    # rule DF.15a_5V is not a DRC check

    # rule DF.15b_3.3V is not a DRC check

    # rule DF.15b_5V is not a DRC check

    # Rule DF.16_3.3V: Min. space from (Nwell outside DNWELL) to (NCOMP outside Nwell and DNWELL). is 0.43µm
    logger.info("Executing rule DF.16_3.3V")
    df16_l1  = ncomp_3p3v.and(ncomp_out_nw_dn).not_inside(ymtp_mk).outside(sramcore).separation(nwell_n_dn.not_inside(ymtp_mk), 0.43.um, euclidian).polygons(0.001)
    df16_l1.output("DF.16_3.3V", "DF.16_3.3V : Min. space from (Nwell outside DNWELL) to (NCOMP outside Nwell and DNWELL). : 0.43µm")
    df16_l1.forget

    # Rule DF.16_5V: Min. space from (Nwell outside DNWELL) to (NCOMP outside Nwell and DNWELL). is 0.6µm
    logger.info("Executing rule DF.16_5V")
    df16_l1  = ncomp_56v.and(ncomp_out_nw_dn).not_inside(ymtp_mk).outside(sramcore).separation(nwell_n_dn.not_inside(ymtp_mk), 0.6.um, euclidian).polygons(0.001)
    df16_l1.output("DF.16_5V", "DF.16_5V : Min. space from (Nwell outside DNWELL) to (NCOMP outside Nwell and DNWELL). : 0.6µm")
    df16_l1.forget

    # Rule DF.17_3.3V: Min. space from (Nwell Outside DNWELL) to (PCOMP outside Nwell and DNWELL) is 0.12µm.
    logger.info("Executing rule DF.17_3.3V")
    df17_l1  = pcomp_3p3v.and(pcomp_out_nw_dn).separation(nwell_n_dn, 0.12.um, euclidian).polygons(0.001)
    df17_l1.output("DF.17_3.3V", "DF.17_3.3V : Min. space from (Nwell Outside DNWELL) to (PCOMP outside Nwell and DNWELL). : 0.12µm")
    df17_l1.forget

    # Rule DF.17_5V: Min. space from (Nwell Outside DNWELL) to (PCOMP outside Nwell and DNWELL) is 0.16µm.
    logger.info("Executing rule DF.17_5V")
    df17_l1  = pcomp_56v.and(pcomp_out_nw_dn).separation(nwell_n_dn, 0.16.um, euclidian).polygons(0.001)
    df17_l1.output("DF.17_5V", "DF.17_5V : Min. space from (Nwell Outside DNWELL) to (PCOMP outside Nwell and DNWELL). : 0.16µm")
    df17_l1.forget

    # Rule DF.18_3.3V: Min. DNWELL space to (PCOMP outside Nwell and DNWELL) is 2.5µm.
    logger.info("Executing rule DF.18_3.3V")
    df18_l1  = pcomp_3p3v.and(pcomp_out_nw_dn).separation(dnwell, 2.5.um, euclidian).polygons(0.001)
    df18_l1.output("DF.18_3.3V", "DF.18_3.3V : Min. DNWELL space to (PCOMP outside Nwell and DNWELL). : 2.5µm")
    df18_l1.forget

    # Rule DF.18_5V: Min. DNWELL space to (PCOMP outside Nwell and DNWELL) is 2.5µm.
    logger.info("Executing rule DF.18_5V")
    df18_l1  = pcomp_56v.and(pcomp_out_nw_dn).separation(dnwell, 2.5.um, euclidian).polygons(0.001)
    df18_l1.output("DF.18_5V", "DF.18_5V : Min. DNWELL space to (PCOMP outside Nwell and DNWELL). : 2.5µm")
    df18_l1.forget
    pcomp_out_nw_dn.forget

    # Rule DF.19_3.3V: Min. DNWELL space to (NCOMP outside Nwell and DNWELL) is 3.2µm.
    logger.info("Executing rule DF.19_3.3V")
    df19_l1  = ncomp_3p3v.and(ncomp_out_nw_dn).separation(dnwell, 3.2.um, euclidian).polygons(0.001)
    df19_l1.output("DF.19_3.3V", "DF.19_3.3V : Min. DNWELL space to (NCOMP outside Nwell and DNWELL). : 3.2µm")
    df19_l1.forget

    # Rule DF.19_5V: Min. DNWELL space to (NCOMP outside Nwell and DNWELL) is 3.28µm.
    logger.info("Executing rule DF.19_5V")
    df19_l1  = ncomp_56v.and(ncomp_out_nw_dn).separation(dnwell, 3.28.um, euclidian).polygons(0.001)
    df19_l1.output("DF.19_5V", "DF.19_5V : Min. DNWELL space to (NCOMP outside Nwell and DNWELL). : 3.28µm")
    df19_l1.forget
    ncomp_out_nw_dn.forget

end #FEOL

